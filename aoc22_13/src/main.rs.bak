#![allow(unused, dead_code)]
use aoc_utils::input;
use lazy_static::lazy_static;
use regex::Regex;

#[derive(Debug, PartialEq)]
enum ListItem {
    Integer(u8),
    List(Vec<ListItem>),
}

fn parse_line(line: &str) -> Vec<ListItem> {
    lazy_static! {
        static ref RE: Regex = Regex::new(r#"(\d+|\[|\])"#).unwrap();
    };

    let mut stack: Vec<Vec<ListItem>> = Vec::new();
    let mut list: Option<Vec<ListItem>> = None;

    for m in RE.find_iter(line) {
        let m = m.as_str();
        dbg!(m);
        match m {
            "[" => match list {
                None => list = Vec::new(),
                Some(list) => {
                    stack.push(list);
                    list = Vec::new()
                }
            },
            "]" => {
                let closed_list = list.expect("`list` should not be None if we encounter a ']'");
                let list = stack.pop;
                list.push(ListItem::List(closed_list));
            }
            _ => list
                .expect("`list` should not be None if we are currently parsing an int")
                .push(ListItem::Integer(m.parse().expect(
                    "substrings other than `[` or `]` should be integers",
                ))),
        }
    }
    list
}

const INPUT: &str = include_str!("../input.txt");

fn part_one(input: &str) -> usize {
    #![allow(unused, dead_code)]
    todo!()
}

fn part_two(input: &str) -> usize {
    #![allow(unused, dead_code)]
    todo!()
}

fn main() {
    println!("Head of INPUT:\n{:?}", input::head(INPUT));
    let part_one_solution = part_one(INPUT);
    println!("Solution to part one: {}", part_one_solution);
    // let part_two_solution = part_two(INPUT);
    // println!("Solution to part two: {}", part_two_solution);
}

#[cfg(test)]
mod tests {
    #![allow(unused, dead_code)]
    use crate::*;

    #[test]
    fn parse_line_test() {
        assert_eq!(
            parse_line("1,2, 3"),
            vec![
                ListItem::Integer(1),
                ListItem::Integer(2),
                ListItem::Integer(3)
            ]
        );
        assert_eq!(
            parse_line("1,2, 3, [4,5]"),
            vec![
                ListItem::Integer(1),
                ListItem::Integer(2),
                ListItem::Integer(3),
                ListItem::List(vec![ListItem::Integer(4), ListItem::Integer(5)])
            ]
        );
    }

    // #[test]
    fn part_one_sample() {
        todo!()
    }

    // #[test]
    fn part_two_sample() {
        todo!()
    }
}
